---
aliases: 
tags: 
date: 2022-01-07 18:27
progress: 加工中
---

# 引言
## 一个基本的MIPS实现
我们将要设计的[[体系结构的实现|实现]]方式包含了MIPS[[指令]]集的一个核心子集：
+ 存储器访问指令：取字（lw）和存字（sw）。
+ 算术逻辑指令：加法（add）、减法（sub）、与运算（AND）、或运算（OR）和小于则设置（slt）。
+ 分支指令：相等则分支（beq）和跳转（j）。

### 实现方式概述
实现每条[[指令]]的前两步是一样的：
1. [[程序计数器]]指向[[指令]]所在的存储单元，并从中取出[[指令]]。
2. 通过[[指令]]字段内容，选取一个或两个寄存器。对于取字[[指令]]，只需读取一个寄存器，而其他大多数[[指令]]要求读取两个寄存器。

这两步之后，为完成[[指令]]而进行的步骤取决与具体[[指令]]的类型。

下图给出了MIPS的抽象视图。
![[《计算机组成与设计：软硬件接口》图4-2.jpg]]

# 逻辑设计的一般方法
MIPS[[体系结构的实现|实现]]中的[[数据通路]]功能部件包括两种不同的逻辑单元：处理数据值的单元和存储状态的单元。处理数据值的单元都是[[组合单元]]，输出之取决与输入;其他单元为非组合单元，而且是包含状态的，称为[[状态单元]]。

包含状态的逻辑部件又被称为时序的（sequential），因为他们的输出由输入和内部状态共同决定。

## 时钟方法
[[时钟方法]]规定了信号可以读出和写入的时间。为简单起见，我们假定采用[[边沿触发的时钟]]。
若某[[状态单元]]在每个[[有效]]时钟边沿都进行写入操作，则可忽略写[[控制信号]]。我们将使用术语[[有效]]和[[无效]]，因为在进行硬件[[体系结构的实现|实现]]时，数字1有时表示逻辑高，有时表示逻辑低。

# 建立数据通路
回顾上图可以看出执行[[指令]]时需要的[[数据通路部件]]：
![[《计算机组成与设计：软硬件接口》图4-2.jpg]]
[[R型指令|算术逻辑指令]]的[[数据通路]]与访存指令的[[数据通路]]很相似。它们的主要区别为：
+ [[R型指令|算术逻辑指令]]使用ALU，并且其输入来自两个寄存器。存储[[指令]]也使用ALU来进行地址计算，但ALU的第二个输入是对[[指令]]中16位偏移地址进行[[符号拓展]]后的值。
+ 存入目标寄存器中的值来自于ALU（对[[R型指令]]而言）或存储器（对取数操作而言）。

# 一个简单的实现机制
## ALU控制
MIPS ALU在4位[[控制信号]]是那个定义了6种[[有效]]的输入组合：

|ALU控制信号|功能|ALU控制信号|功能|
|-|-|-|-|
|0000|与|0110|减|
|0001|或|0111|小于则置位|
|0010|加|1100|或非|

对于取字和存储字[[指令]]，ALU用加法计算存储器地址。对于[[R型指令]]，根据[[指令]]低6位的[[funct]]字段，ALU执行5种操作中的一种（与、或、减、加、小于则置位）。对于相等则分支，ALU执行减法操作。

下表说明了怎样根据2位的ALUOp和6位的[[funct]]功能字段生成ALU的控制信号。

|指令操作码|ALUOp|指令操作|funct字段|ALU动作|ALU控制信号|
|-|-|-|-|-|-|
|取字|00|取字|XXXXXX|加|0010|
|存字|00|存储字|XXXXXX|加|0010|
|相等则分支|01|相等分支|XXXXXX|减|0110|
|R类型|10|加|100000|加|0010|
|R类型|10|减|100010|减|0110|
|R类型|10|与|100100|与|0000|
|R类型|10|或|100101|或|0001|
|R类型|10|小于则置位|101010|小于则置位|0111|

这种[[多级译码]]的方法是一种常用的[[体系结构的实现|实现]]方式。

## 主控单元的设计
![[《计算机组成与设计：软硬件接口》图4-14.jpg]]

MIPS指令格式遵循以下规则：
+ Op字段，第二章亦称[[操作码]]（opcode），总是为31：26位。我们将用Op\[5:0\]来表示。
+ 对于[[R型指令]]、分支指令和存取指令，要读取的两个寄存器为rs和rt字段，分别为25：21位和20：16位。
+ 存取指令的基址寄存器在25：21位中（rs字段）。
+ 相等则分支指令、存取指令的16位偏移量在15：0位中。
+ 有两个地方存放目标寄存器。对取数指令为20：16位（rs字段），对[[R型指令]]为15：11位（[[rd]]字段）。所以我们需要一个多选器，以指示要写的寄存器在哪个字段中。

![[《计算机组成与设计：软硬件接口》图4-15.jpg]]
![[《计算机组成与设计：软硬件接口》图4-16.jpg]]

### 数据通路的操作
下图为包含控制单元的简单数据通路和按指令[[操作码]]设置的控制信号
![[《计算机组成与设计：软硬件接口》图4-17.jpg]]
![[《计算机组成与设计：软硬件接口》图4-18.jpg]]

根据上面两图和[[《计算机组成与设计：软硬件接口》图4-16.jpg|图4-16]]分析三种指令的[[数据通路]]操作
#### [[R型指令]]
![[《计算机组成与设计：软硬件接口》图4-19.jpg]]
一切发生于一个时钟周期，将其分为4步：
1. 从指令存储器中取出[[指令]]，[[程序计数器|PC]]自增。
2. 从[[寄存器堆]]中取出寄存器，同时，主控制单元计算出个[[控制信号]]的状态。
3. ALU根据[[funct]]字段确定ALU的功能，对从[[寄存器堆]]读出的数据进行操作。
4. 将ALU的结果写入[[寄存器堆]]，根据[[指令]]的15：11位选择目标寄存器。

#### 取数指令
![[《计算机组成与设计：软硬件接口》图4-20.jpg]]
考虑将取数指令分为5步：
1. 从指令存储器取指，[[程序计数器|PC]]自增。
2. 从[[寄存器堆]]读出寄存器的值。
3. ALU将从[[寄存器堆]]读出的与[[符号拓展]]后的[[指令]]低16位值相加。
4. 将ALU的结果作为数据存储器的地址。
5. 存储单元的数据写入[[寄存器堆]]，目标寄存器由[[指令]]20：16位指出。

#### 分支指令
![[《计算机组成与设计：软硬件接口》图4-21.jpg]]
分为4个步骤：
1. 从指令存储器中取指，[[程序计数器|PC]]自增。
2. 从[[寄存器堆]]读出寄存器的值。
3. ALU将从[[寄存器堆]]读出的两数相减。[[程序计数器|PC]]+4的值与[[符号拓展]]并左移2位后的[[指令]]低16位相加，结果即分支指令地址。
4. 根据ALU的零输出决定哪个加法器的结果存入[[程序计数器|PC]]中。

### 控制的结束
根据6位操作码Op\[5:0\]得出控制信号
![[《计算机组成与设计：软硬件接口》图4-22.jpg]]
### 续，跳转指令的实现
跳转指令的操作码=2，跳转地址的最低两位为$00_2$，次低26位来自指令的26位立即数，高四位来自于跳转指令的PC+4。
![[《计算机组成与设计：软硬件接口》图4-24.jpg]]

# 流水线概述
![[流水线]]
理想情况下流水线机器上的指令执行时间为
$$指令执行时间_{流水线}=\frac {指令执行时间_{非流水线}}{流水线级数}$$

## 面向流水线的指令集设计
1. 所有的MIPS[[指令]]的长度都是相同的。这一限制简化了[[流水线]]的第一级取指与第二级译码。
2. MIPS只有很少的几种[[指令]]格式，并且每一条[[指令]]中的源寄存器字段位置都是相同的。这种对称性意味着[[流水线]]的第二级在确定取指类型的同时就能够开始读[[寄存器堆]]。
3. MIPS中的存储器操作数仅出现在存取[[指令]]中。这一限制意味着可以利用执行级计算存储器地址，然后可以接着在下一级访问存储器。
4. 所有操作数必须在存储器中对齐。因此，我们不需要担心一个数据传输[[指令]]需要访问两次存储器的情况。
